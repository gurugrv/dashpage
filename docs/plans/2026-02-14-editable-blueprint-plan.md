# Editable Blueprint Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Allow users to edit blueprint design system (colors, fonts, mood) and content strategy (tone, audience, CTA, brand voice) inline on the BlueprintCard before generating pages.

**Architecture:** The existing read-only BlueprintCard gains an edit/view toggle. Local draft state is managed inside the card. On "Done", edits propagate up through a new `onUpdate` callback to the hook which updates React state and persists via a new PATCH endpoint. No new pages/routes/layouts.

**Tech Stack:** React 19, shadcn/ui Popover (new), existing Input component, Prisma 7, Next.js 16 API routes.

**Design doc:** `docs/plans/2026-02-14-editable-blueprint-design.md`

**Note:** No test framework is configured in this project. Verification is manual via `npm run build` and browser testing.

---

### Task 1: Add shadcn Popover component

**Files:**
- Create: `src/components/ui/popover.tsx` (generated by shadcn CLI)

**Step 1: Install the Popover component**

Run: `npx shadcn@latest add popover`

This generates the Popover primitives needed for color picker popovers.

**Step 2: Verify it was added**

Run: `ls src/components/ui/popover.tsx`
Expected: File exists.

**Step 3: Commit**

```bash
git add src/components/ui/popover.tsx
git commit -m "chore: add shadcn popover component"
```

---

### Task 2: Add PATCH endpoint for blueprint updates

**Files:**
- Modify: `src/app/api/blueprint/[conversationId]/route.ts` (currently only has GET)

**Step 1: Add the PATCH handler**

Add a `PATCH` export alongside the existing `GET`. It receives `{ blueprint }` in the JSON body and updates `Blueprint.data` in the database.

```typescript
export async function PATCH(
  req: Request,
  { params }: { params: Promise<{ conversationId: string }> },
) {
  const { conversationId } = await params;

  let body: { blueprint: unknown };
  try {
    body = await req.json();
  } catch {
    return NextResponse.json({ error: 'Invalid request body' }, { status: 400 });
  }

  if (!body.blueprint) {
    return NextResponse.json({ error: 'blueprint is required' }, { status: 400 });
  }

  try {
    await prisma.blueprint.update({
      where: { conversationId },
      data: { data: body.blueprint as Record<string, unknown> },
    });
    return NextResponse.json({ ok: true });
  } catch {
    return NextResponse.json({ error: 'Blueprint not found' }, { status: 404 });
  }
}
```

**Step 2: Verify build**

Run: `npm run build`
Expected: Build succeeds with no errors.

**Step 3: Commit**

```bash
git add src/app/api/blueprint/[conversationId]/route.ts
git commit -m "feat: add PATCH endpoint for blueprint updates"
```

---

### Task 3: Add `updateBlueprint` to useBlueprintGeneration hook

**Files:**
- Modify: `src/hooks/useBlueprintGeneration.ts`

**Step 1: Add the `updateBlueprint` function**

Inside the `useBlueprintGeneration` function, add a new callback that:
1. Updates the `blueprint` React state with the new value
2. Fires a fire-and-forget PATCH request to persist the edit

```typescript
const updateBlueprint = useCallback((updated: Blueprint, conversationId: string) => {
  setBlueprint(updated);
  // Fire-and-forget persistence
  fetch(`/api/blueprint/${conversationId}`, {
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ blueprint: updated }),
  }).catch(() => {});
}, []);
```

**Step 2: Export it from the return object**

Add `updateBlueprint` to the returned object at line ~362, alongside `blueprint`, `generateBlueprint`, etc.

```typescript
return {
  phase,
  blueprint,
  pageStatuses,
  error,
  headerHtml,
  footerHtml,
  generateBlueprint,
  generatePages,
  approveAndGenerate,
  resumeFromState,
  updateBlueprint,  // NEW
  cancel,
  reset,
};
```

**Step 3: Verify build**

Run: `npm run build`
Expected: Build succeeds.

**Step 4: Commit**

```bash
git add src/hooks/useBlueprintGeneration.ts
git commit -m "feat: add updateBlueprint to blueprint generation hook"
```

---

### Task 4: Wire `updateBlueprint` through Builder and PromptPanel

**Files:**
- Modify: `src/components/Builder.tsx` (lines 128-143 destructuring, lines 609-660 PromptPanel props)
- Modify: `src/components/PromptPanel.tsx` (interface + usage)

**Step 1: Destructure `updateBlueprint` from the hook in Builder.tsx**

At line ~128 where `useBlueprintGeneration` is destructured, add `updateBlueprint`:

```typescript
const {
  phase: blueprintPhase,
  blueprint,
  pageStatuses,
  error: blueprintError,
  generateBlueprint,
  approveAndGenerate,
  resumeFromState,
  updateBlueprint,  // NEW
  cancel: cancelBlueprint,
  reset: resetBlueprint,
} = useBlueprintGeneration({ ... });
```

**Step 2: Create a handler in Builder.tsx**

Add after `handleBlueprintRegenerate` (~line 499):

```typescript
const handleBlueprintUpdate = useCallback((updated: Blueprint) => {
  if (!activeConversationId) return;
  updateBlueprint(updated, activeConversationId);
}, [activeConversationId, updateBlueprint]);
```

**Step 3: Pass to PromptPanel**

In the PromptPanel JSX (~line 654), add the new prop:

```tsx
onBlueprintUpdate={handleBlueprintUpdate}
```

**Step 4: Add to PromptPanel interface and usage**

In `src/components/PromptPanel.tsx`:

1. Add to `PromptPanelProps` interface (~line 48):
```typescript
onBlueprintUpdate?: (blueprint: Blueprint) => void;
```

2. Destructure in function params (~line 84):
```typescript
onBlueprintUpdate,
```

3. Pass to BlueprintCard (~line 116-121):
```tsx
<BlueprintCard
  blueprint={blueprint}
  onApprove={onBlueprintApprove ?? (() => {})}
  onRegenerate={onBlueprintRegenerate ?? (() => {})}
  onCancel={onBlueprintCancel ?? (() => {})}
  onUpdate={onBlueprintUpdate}
/>
```

**Step 5: Verify build**

Run: `npm run build`
Expected: Build succeeds.

**Step 6: Commit**

```bash
git add src/components/Builder.tsx src/components/PromptPanel.tsx
git commit -m "feat: wire updateBlueprint through Builder and PromptPanel"
```

---

### Task 5: Implement edit mode in BlueprintCard

**Files:**
- Modify: `src/features/blueprint/blueprint-card.tsx`

This is the main UI task. The card gains `isEditing` state and a `draft` copy of the blueprint.

**Step 1: Update imports and props**

Add imports for `useState`, `Popover`/`PopoverTrigger`/`PopoverContent`, and `Pencil` icon. Add `onUpdate` to the props interface:

```typescript
'use client';

import { useState } from 'react';
import { FileText, Navigation, Palette, Pencil, Type, Users, Megaphone } from 'lucide-react';
import { Button } from '@/components/ui/button';
import { Popover, PopoverTrigger, PopoverContent } from '@/components/ui/popover';
import type { Blueprint, BlueprintDesignSystem, BlueprintContentStrategy } from '@/lib/blueprint/types';

interface BlueprintCardProps {
  blueprint: Blueprint;
  onApprove: () => void;
  onRegenerate: () => void;
  onCancel: () => void;
  onUpdate?: (blueprint: Blueprint) => void;
  disabled?: boolean;
}
```

**Step 2: Add edit state and draft management**

Inside the component function, add:

```typescript
const [isEditing, setIsEditing] = useState(false);
const [draft, setDraft] = useState<Blueprint>(blueprint);

const designSource = isEditing ? draft.designSystem : designSystem;
const strategySource = isEditing ? draft.contentStrategy : contentStrategy;

const updateDesign = (field: keyof BlueprintDesignSystem, value: string) => {
  setDraft((prev) => ({
    ...prev,
    designSystem: { ...prev.designSystem, [field]: value },
  }));
};

const updateStrategy = (field: keyof BlueprintContentStrategy, value: string) => {
  setDraft((prev) => ({
    ...prev,
    contentStrategy: { ...prev.contentStrategy, [field]: value },
  }));
};

const handleEdit = () => {
  setDraft(blueprint);
  setIsEditing(true);
};

const handleDone = () => {
  setIsEditing(false);
  onUpdate?.(draft);
};
```

**Step 3: Update the colors array to use `designSource`**

```typescript
const colors: { label: string; value: string; field: keyof BlueprintDesignSystem }[] = [
  { label: 'Primary', value: designSource.primaryColor, field: 'primaryColor' },
  { label: 'Secondary', value: designSource.secondaryColor, field: 'secondaryColor' },
  { label: 'Accent', value: designSource.accentColor, field: 'accentColor' },
  { label: 'Background', value: designSource.backgroundColor, field: 'backgroundColor' },
  { label: 'Surface', value: designSource.surfaceColor, field: 'surfaceColor' },
  { label: 'Text', value: designSource.textColor, field: 'textColor' },
];
```

**Step 4: Update Color Palette section**

Replace the color palette rendering. In view mode, circles are static (current behavior). In edit mode, each circle is wrapped in a Popover with a hex input:

```tsx
{/* Color Palette */}
<div className="flex items-center gap-2">
  <Palette className="size-3.5 shrink-0 text-muted-foreground" />
  <div className="flex items-center gap-1.5">
    {colors.map((c) =>
      isEditing ? (
        <Popover key={c.label}>
          <PopoverTrigger asChild>
            <button
              className="size-5 rounded-full border border-border/50 shadow-sm ring-offset-background transition-transform hover:scale-110 focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring"
              style={{ backgroundColor: c.value }}
              title={`${c.label}: ${c.value}`}
            />
          </PopoverTrigger>
          <PopoverContent className="w-48 p-3" align="start">
            <label className="mb-1.5 block text-xs font-medium">{c.label}</label>
            <div className="flex items-center gap-2">
              <div
                className="size-6 shrink-0 rounded border border-border/50"
                style={{ backgroundColor: c.value }}
              />
              <input
                type="text"
                className="h-7 w-full rounded border border-input bg-transparent px-2 text-xs focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring"
                value={c.value}
                onChange={(e) => updateDesign(c.field, e.target.value)}
              />
            </div>
          </PopoverContent>
        </Popover>
      ) : (
        <div
          key={c.label}
          className="size-5 rounded-full border border-border/50 shadow-sm"
          style={{ backgroundColor: c.value }}
          title={`${c.label}: ${c.value}`}
        />
      ),
    )}
  </div>
  {isEditing ? (
    <input
      type="text"
      className="min-w-0 flex-1 border-b border-dashed border-input bg-transparent text-xs text-muted-foreground focus-visible:outline-none focus-visible:border-ring"
      value={designSource.mood}
      onChange={(e) => updateDesign('mood', e.target.value)}
    />
  ) : (
    <span className="text-xs text-muted-foreground">{designSystem.mood}</span>
  )}
</div>
```

**Step 5: Update Typography section**

```tsx
{/* Typography */}
<div className="flex items-center gap-2">
  <Type className="size-3.5 shrink-0 text-muted-foreground" />
  {isEditing ? (
    <div className="flex items-center gap-1 text-xs">
      <input
        type="text"
        className="w-32 border-b border-dashed border-input bg-transparent font-medium focus-visible:outline-none focus-visible:border-ring"
        value={designSource.headingFont}
        onChange={(e) => updateDesign('headingFont', e.target.value)}
      />
      <span className="text-muted-foreground">/</span>
      <input
        type="text"
        className="w-32 border-b border-dashed border-input bg-transparent focus-visible:outline-none focus-visible:border-ring"
        value={designSource.bodyFont}
        onChange={(e) => updateDesign('bodyFont', e.target.value)}
      />
    </div>
  ) : (
    <span className="text-xs">
      <span className="font-medium">{designSystem.headingFont}</span>
      <span className="text-muted-foreground"> / </span>
      <span>{designSystem.bodyFont}</span>
    </span>
  )}
</div>
```

**Step 6: Update Content Strategy section**

```tsx
{/* Content Strategy */}
<div className="flex items-center gap-2">
  <Users className="size-3.5 shrink-0 text-muted-foreground" />
  {isEditing ? (
    <input
      type="text"
      className="min-w-0 flex-1 border-b border-dashed border-input bg-transparent text-xs text-muted-foreground focus-visible:outline-none focus-visible:border-ring"
      value={strategySource.targetAudience}
      onChange={(e) => updateStrategy('targetAudience', e.target.value)}
    />
  ) : (
    <span className="text-xs text-muted-foreground">{contentStrategy.targetAudience}</span>
  )}
</div>
<div className="flex items-center gap-2">
  <Megaphone className="size-3.5 shrink-0 text-muted-foreground" />
  {isEditing ? (
    <input
      type="text"
      className="min-w-0 flex-1 border-b border-dashed border-input bg-transparent text-xs text-muted-foreground focus-visible:outline-none focus-visible:border-ring"
      value={strategySource.tone}
      onChange={(e) => updateStrategy('tone', e.target.value)}
    />
  ) : (
    <span className="text-xs text-muted-foreground">{contentStrategy.tone}</span>
  )}
</div>
```

**Step 7: Update Actions section**

Replace the actions footer to include Edit/Done button and disable Generate while editing:

```tsx
{/* Actions */}
<div className="flex items-center gap-2 border-t px-4 py-3">
  <Button size="sm" onClick={onApprove} disabled={disabled || isEditing}>
    Generate Pages
  </Button>
  {isEditing ? (
    <Button size="sm" variant="outline" onClick={handleDone}>
      Done
    </Button>
  ) : (
    <Button size="sm" variant="outline" onClick={handleEdit} disabled={disabled}>
      <Pencil className="mr-1 size-3" />
      Edit
    </Button>
  )}
  <Button size="sm" variant="outline" onClick={onRegenerate} disabled={disabled || isEditing}>
    Regenerate
  </Button>
  <Button size="sm" variant="ghost" onClick={onCancel} disabled={disabled}>
    Cancel
  </Button>
</div>
```

**Step 8: Verify build**

Run: `npm run build`
Expected: Build succeeds.

**Step 9: Commit**

```bash
git add src/features/blueprint/blueprint-card.tsx
git commit -m "feat: add inline edit mode to BlueprintCard"
```

---

### Task 6: Final verification

**Step 1: Full build check**

Run: `npm run build`
Expected: Build succeeds with no errors.

**Step 2: Lint check**

Run: `npm run lint`
Expected: No lint errors.

**Step 3: Manual testing checklist**

1. Start dev server: `npm run dev`
2. Create a new conversation with a multi-page prompt (e.g., "Build a 5-page restaurant website")
3. Verify BlueprintCard appears with "Edit" button alongside existing buttons
4. Click "Edit" — verify:
   - Color circles become clickable (open popover with hex input)
   - Font fields become text inputs
   - Mood, audience, tone become text inputs
   - "Edit" button changes to "Done"
   - "Generate Pages" is disabled
5. Change a color hex value — verify the circle updates live
6. Change a font name — verify text updates
7. Click "Done" — verify card returns to view mode with updated values
8. Navigate away and return to the conversation — verify edits persist
9. Click "Generate Pages" — verify the generated site uses the edited colors/fonts
10. Click "Regenerate" — verify it regenerates a new blueprint (replacing edits)

**Step 4: Final commit if any fixes needed**

```bash
git add -A
git commit -m "fix: address issues found during manual testing"
```
